// Code generated by mockery v2.39.1. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "go-clean-template/entity"

	mock "github.com/stretchr/testify/mock"

	usecase "go-clean-template/usecase"
)

// ITransactionRepository is an autogenerated mock type for the ITransactionRepository type
type ITransactionRepository struct {
	mock.Mock
}

type ITransactionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *ITransactionRepository) EXPECT() *ITransactionRepository_Expecter {
	return &ITransactionRepository_Expecter{mock: &_m.Mock}
}

// GetAccountByID provides a mock function with given fields: ctx, accountID
func (_m *ITransactionRepository) GetAccountByID(ctx context.Context, accountID string) (*entity.Account, error) {
	ret := _m.Called(ctx, accountID)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountByID")
	}

	var r0 *entity.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Account, error)); ok {
		return rf(ctx, accountID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Account); ok {
		r0 = rf(ctx, accountID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ITransactionRepository_GetAccountByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountByID'
type ITransactionRepository_GetAccountByID_Call struct {
	*mock.Call
}

// GetAccountByID is a helper method to define mock.On call
//   - ctx context.Context
//   - accountID string
func (_e *ITransactionRepository_Expecter) GetAccountByID(ctx interface{}, accountID interface{}) *ITransactionRepository_GetAccountByID_Call {
	return &ITransactionRepository_GetAccountByID_Call{Call: _e.mock.On("GetAccountByID", ctx, accountID)}
}

func (_c *ITransactionRepository_GetAccountByID_Call) Run(run func(ctx context.Context, accountID string)) *ITransactionRepository_GetAccountByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ITransactionRepository_GetAccountByID_Call) Return(_a0 *entity.Account, _a1 error) *ITransactionRepository_GetAccountByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ITransactionRepository_GetAccountByID_Call) RunAndReturn(run func(context.Context, string) (*entity.Account, error)) *ITransactionRepository_GetAccountByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletByID provides a mock function with given fields: ctx, walletID
func (_m *ITransactionRepository) GetWalletByID(ctx context.Context, walletID string) (*entity.Wallet, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for GetWalletByID")
	}

	var r0 *entity.Wallet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Wallet, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Wallet); ok {
		r0 = rf(ctx, walletID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Wallet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ITransactionRepository_GetWalletByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletByID'
type ITransactionRepository_GetWalletByID_Call struct {
	*mock.Call
}

// GetWalletByID is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
func (_e *ITransactionRepository_Expecter) GetWalletByID(ctx interface{}, walletID interface{}) *ITransactionRepository_GetWalletByID_Call {
	return &ITransactionRepository_GetWalletByID_Call{Call: _e.mock.On("GetWalletByID", ctx, walletID)}
}

func (_c *ITransactionRepository_GetWalletByID_Call) Run(run func(ctx context.Context, walletID string)) *ITransactionRepository_GetWalletByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ITransactionRepository_GetWalletByID_Call) Return(_a0 *entity.Wallet, _a1 error) *ITransactionRepository_GetWalletByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ITransactionRepository_GetWalletByID_Call) RunAndReturn(run func(context.Context, string) (*entity.Wallet, error)) *ITransactionRepository_GetWalletByID_Call {
	_c.Call.Return(run)
	return _c
}

// SaveTransaction provides a mock function with given fields: ctx, trans
func (_m *ITransactionRepository) SaveTransaction(ctx context.Context, trans *entity.Transaction) error {
	ret := _m.Called(ctx, trans)

	if len(ret) == 0 {
		panic("no return value specified for SaveTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.Transaction) error); ok {
		r0 = rf(ctx, trans)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ITransactionRepository_SaveTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveTransaction'
type ITransactionRepository_SaveTransaction_Call struct {
	*mock.Call
}

// SaveTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - trans *entity.Transaction
func (_e *ITransactionRepository_Expecter) SaveTransaction(ctx interface{}, trans interface{}) *ITransactionRepository_SaveTransaction_Call {
	return &ITransactionRepository_SaveTransaction_Call{Call: _e.mock.On("SaveTransaction", ctx, trans)}
}

func (_c *ITransactionRepository_SaveTransaction_Call) Run(run func(ctx context.Context, trans *entity.Transaction)) *ITransactionRepository_SaveTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.Transaction))
	})
	return _c
}

func (_c *ITransactionRepository_SaveTransaction_Call) Return(_a0 error) *ITransactionRepository_SaveTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ITransactionRepository_SaveTransaction_Call) RunAndReturn(run func(context.Context, *entity.Transaction) error) *ITransactionRepository_SaveTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWalletBalance provides a mock function with given fields: ctx, walletID, balance
func (_m *ITransactionRepository) UpdateWalletBalance(ctx context.Context, walletID string, balance float64) error {
	ret := _m.Called(ctx, walletID, balance)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWalletBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) error); ok {
		r0 = rf(ctx, walletID, balance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ITransactionRepository_UpdateWalletBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWalletBalance'
type ITransactionRepository_UpdateWalletBalance_Call struct {
	*mock.Call
}

// UpdateWalletBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
//   - balance float64
func (_e *ITransactionRepository_Expecter) UpdateWalletBalance(ctx interface{}, walletID interface{}, balance interface{}) *ITransactionRepository_UpdateWalletBalance_Call {
	return &ITransactionRepository_UpdateWalletBalance_Call{Call: _e.mock.On("UpdateWalletBalance", ctx, walletID, balance)}
}

func (_c *ITransactionRepository_UpdateWalletBalance_Call) Run(run func(ctx context.Context, walletID string, balance float64)) *ITransactionRepository_UpdateWalletBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *ITransactionRepository_UpdateWalletBalance_Call) Return(_a0 error) *ITransactionRepository_UpdateWalletBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ITransactionRepository_UpdateWalletBalance_Call) RunAndReturn(run func(context.Context, string, float64) error) *ITransactionRepository_UpdateWalletBalance_Call {
	_c.Call.Return(run)
	return _c
}

// WithDBTransaction provides a mock function with given fields: tx
func (_m *ITransactionRepository) WithDBTransaction(tx usecase.IDBTransaction) usecase.ITransactionRepository {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for WithDBTransaction")
	}

	var r0 usecase.ITransactionRepository
	if rf, ok := ret.Get(0).(func(usecase.IDBTransaction) usecase.ITransactionRepository); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(usecase.ITransactionRepository)
		}
	}

	return r0
}

// ITransactionRepository_WithDBTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithDBTransaction'
type ITransactionRepository_WithDBTransaction_Call struct {
	*mock.Call
}

// WithDBTransaction is a helper method to define mock.On call
//   - tx usecase.IDBTransaction
func (_e *ITransactionRepository_Expecter) WithDBTransaction(tx interface{}) *ITransactionRepository_WithDBTransaction_Call {
	return &ITransactionRepository_WithDBTransaction_Call{Call: _e.mock.On("WithDBTransaction", tx)}
}

func (_c *ITransactionRepository_WithDBTransaction_Call) Run(run func(tx usecase.IDBTransaction)) *ITransactionRepository_WithDBTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(usecase.IDBTransaction))
	})
	return _c
}

func (_c *ITransactionRepository_WithDBTransaction_Call) Return(_a0 usecase.ITransactionRepository) *ITransactionRepository_WithDBTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ITransactionRepository_WithDBTransaction_Call) RunAndReturn(run func(usecase.IDBTransaction) usecase.ITransactionRepository) *ITransactionRepository_WithDBTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewITransactionRepository creates a new instance of ITransactionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewITransactionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *ITransactionRepository {
	mock := &ITransactionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
